<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="author" content="iaGuoZhi">
  <link rel="shortcut icon" href="https://blog.thea.codes/favicon.ico">

  <title>Linux SVA分析 - iaGuoZhi</title>

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" href="https://blog.thea.codes/feed.xml" />

  <!-- Bootstrap core CSS -->
  <link href="/static/bootstrap.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="/static/style.css" rel="stylesheet">

  <!-- Syntax highlighting css -->
  <link href="/static/pygments.css" rel="stylesheet">

  
<meta property="og:title" content="Linux SVA分析 - iaGuoZhi">
<meta property="twitter:title" content="Linux SVA分析 - iaGuoZhi">







<meta property="og:url" content="https://blog.thea.codes/linux-sva-analysis">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:site" content="@theavalkyrie">

</head>
<body>
  <div class="container">

    
<article>
  <aside class="timestamp">
    <time>Posted by iaGuoZhi on February 28, 2022</time>
    · <a href="/">view all posts</a>
  </aside>
  <h1>Linux SVA分析</h1>
  <content>
    <h1 id="_1">使用场景介绍</h1>
<p>SVA特性可以做到进程虚拟地址在进程和设备之间共享。最直观的使用场景就是在用户态做DMA。</p>
<p>在SVA的支持下，我们可以在用户态进程malloc一段内存，然后把得到va直接配置给设备的DMA，然后启动DMA向va对应的虚拟地址写数据，当然也可以从va对应的虚拟地址上往设备读数据。这里我们把设备DMA相关的寄存器先mmap到用户态，这样DMA操作在用户态就可以完成。</p>
<p><strong>SVA可以支持的功能很大一部分取决于设备的功能，SVA就是提供一个进程和设备一致的虚拟地址空间，其他的设备向怎么用都可以。</strong> 如果设备做的足够强，设备完全可以执行va上对应的代码。</p>
<p><em>设备完全可以将自身的资源分配给不同的进程同时使用</em>。</p>
<p>为了满足上面的使用场景，SVA特性需要硬件支持IOMMU以及设备发起缺页。在下一节先介绍硬件，再基于此分析SVA的软件实现。</p>
<h1 id="_2">硬件基础介绍</h1>
<p>本文以ARM64体系结构为基础分析，在ARM64下，IOMMU即是SMMU。对于设备，ARM64下有平台设备与PCI设备。整体的硬件示意图如下，图中也画出了硬件工作时相关的内存里的数据结构。</p>
<p>基于上一节提到的使用场景，我们梳理硬件中的逻辑关系。调用malloc后，其实只是拿到了一个虚拟地址，内核并没有为申请的地址空间分配实际的物理内存，直到访问这块地址空间时引发缺页，内核在缺页流程里分配实际的物理内存，然后建立虚拟地址到物理内存的映射。这个过程需要MMU的参与。在SVA的场景中，设备拿到malloc得到的va后，需要通过DMA访问地址空间，但是此时va并没有分配实际的物理内存，所以设备一侧的访问流程必然需要进行类似的缺页请求。支持设备侧缺页请求的硬件设备就是SMMU，其中对于PCI设备，还需要<em>ATS, PRI</em>硬件特性支持。平台设备需要SMMU stall mode支持（使用event queue）。PCI设备和平台设备都需要PASID特性的支持。</p>
<p>引入SVA后，MMU和SMMU使用相同的进程页表，SMMU使用<strong>STE</strong>和<strong>CD</strong>表管理当前SMMU下设备的页表，其中STE表用来区分设备，CD表用来区分同一设备分配给不同进程使用的硬件资源所对应的进程页表。STE表和CD表都需要SMMU驱动预先分配好。</p>
<p>SMMU内部使用command queue，event queue，pri queue做基本的事件管理。当有对应的硬件事件发生时，硬件将相应的描述符写入event queue或者pri queue，然后上报中断。软件使用command queue下发相应的命令操作硬件。</p>
<p>PCI设备和平台设备的硬件缺页流程存在差异，下面分别介绍。对于PCI设备，ATS，PRI和PASID的概念同时存在于PCIe和SMMU规范中。简单来说，ATS特性由设备侧的ATC和SMMU侧的ATS同时支持，其目的是在设备中缓存va对应的pa，设备随后使用pa做内存访问时无需经过SMMU页表转换，以提高性能。PRI（page request interface）也是需要设备和SMMU一起工作，PCIe设备可以发出缺页请求，SMMU硬件在解析到缺页请求后可以直接将缺页请求写入PRI queue，软件在建立好页表后，可以通过CMD queue发送PRI response给PCIe设备。具体的ATS和PRI的实现是硬件相关的，目前市面上还没有实现这两个硬件特性的PCIe设备，但是我们可以设想一下ATS和PRI的硬件实现，最好的实现应该是软件透明的，也就是软件配置给设备DMA的访问地址是va，软件控制DMA发起后，硬件先发起ATC请求，从SMMU请求该va对应的pa，如果SMMU里已经有va到pa的映射，那么设备可以得到pa，然后设备再用pa发起一次内存访问，该访问将直接访问对应pa地址，不在SMMU做地址翻译，如果SMMU没有va到pa的映射，那么设备得到这个消息后会继续向SMMU发PRI请求，设备得到从SMMU来的PRI response后发送内存访问请求，该请求就可以在SMMU中翻译得到pa，最终访问到物理内存。</p>
<p>PRI请求是基于PCIe协议的，平台设备无法用PRI发起缺页请求。实际上，平台设备是无法靠自身发起缺页请求的，SMMU使用stall模式支持平台设备的缺页，当一个平台设备的内存访问请求到达SMMU后，如果SMMU里没有为va做到pa的映射，硬件会给SMMU的event queue写一个信息，SMMU的event queue中断处理里可以做缺页处理，然后SMMU可以回信息给设备（fix me:请求设备重发，还是SMMU缺页处理后已经把该访问翻译后送到上游总线）。实际上，SMMU使用event queue来处理各种错误异常，这里的stall模式是借用了event queue来处理缺页。</p>
<p>可以注意到PRI和stall模式完成缺页的区别是，PRI缺页的时候并不是在IO实际发生的时候，因为如果PRI response表示PRI请求失败，硬件完全可以不发起后续的IO操作。而stall模式，完全发生在IO请求的途中。所以，它被叫做stall模式。</p>
<h1 id="pcie-ats">PCIe ATS协议分析</h1>
<h2 id="translation-request">translation request</h2>
<ul>
<li>Length</li>
</ul>
<p>这个地方的数值表示的是dword的个数，因为一个translation request是两个dword，所以如果Length是2,就表示请求untranslated address开始的一个STU大小的翻译，如果大于2就表示Length/2 个STU大小的翻译，可见LEngth总是偶数。</p>
<ul>
<li>Untranslated address</li>
</ul>
<p>需要翻译的VA，size是2^(STU + 12) * (Length/2) Byte。STU就是ATS capability里的STU域段的数值。这个VA总是要和STU表示的大小对齐。</p>
<h2 id="translation-complettion">translation complettion</h2>
<p>翻译的结果用这个消息返回给PCIe设备。如果翻译成功，在completion的报文中就带有payload，payload中有Translated address，S，N，Global，W，R等域段。</p>
<ul>
<li>Status</li>
</ul>
<p>表示翻译的结果。</p>
<ul>
<li>Translated address和S</li>
</ul>
<p>翻译后的PA，这个地址覆盖的size需要S域段和地址本身确定。S为0表示size的值是4096,S为1就要看PA其中的bit了，bit12为0表示8KB，bit13/bit12为0/1表示16KB，以此类推。</p>
<ul>
<li>Gloabl</li>
</ul>
<p>表示翻译得到的结果的作用范围，如果是1,表示是整个设备，如果是0,设备需要配合PASID给这个翻译项创建ATC，这样范围就被限定在了PASID的范围内。</p>
<h2 id="invalidate-request">invalidate request</h2>
<p>无效化一段VA在ATC中的缓存。</p>
<ul>
<li>Untranslated address 和S</li>
</ul>
<p>和上面的意思一样</p>
<ul>
<li>Global</li>
</ul>
<p>和上面的意思一样，表示PASID这个因素要不要加到invalidate里来。</p>
<h2 id="ats-capability">ATS capability</h2>
<ul>
<li>cap head</li>
<li>Capability register</li>
<li>Control register</li>
</ul>
<h1 id="pcie-pri">PCIe PRI协议分析</h1>
<p>PRI依赖ATS，带有PRI功能的受灾，可以给IOMMU发page request，IOMMU为设备申请物理页，并建立页表后，给设备发PRG response。</p>
<p>PCIe协议里定义了PCIe设备和IOMMU之间的request/response消息格式，并且定义了PRI capability的格式，后者是软件可以读写的软硬件接口。</p>
<p>先看PRI capability的详细定义，这个cap只在PF里有:</p>
<ul>
<li>cap head</li>
</ul>
<p>常规cap头</p>
<ul>
<li>status register</li>
</ul>
<p>response failure bit: 读到1表示收到一个failure的response。RW1C寄存器，写1清0.</p>
<p>unexpected page request group index bit: 读到1表示收到一个非法PRI group index。RW1C寄存器，写1清零。</p>
<p>stopped bit</p>
<ul>
<li>control register</li>
</ul>
<p>enable bit: 控制是否可以发PRI request。</p>
<p>reset bit</p>
<p>........</p>
<h2 id="linux">Linux驱动分析</h2>
<p>目前Linux主线（Linux-5.14-rc4)已经支持了PCIe PRI的基本使能函数。相关函数在drivers/pci/ats.c中，<em>这些只是一些PCIe cap的操作函数，在业务中使用PRI功能的情况还没有</em></p>
<p>可以通过SMMU_IDR0寄存器的ATS和PRI两个bit判断SMMU是否支持ATS与PRI特性。</p>
  </content>
</article>


    <footer>
      <div class="row">
        <div class="col-md-1 d-none d-md-block img-me-container">
          <img class="img-me img-fluid" src="/static/me.jpg">
        </div>
        <div class="col-md info">
          <span class="name">iaGuoZhi</span><br>
          <!--<a href="https://thea.codes"><i class="fa fa-link" aria-hidden="true"></i> thea.codes</a>-->
          <a href="@zhiguo:matrix.org" rel="noopener"><i class="fab fa-matrix" aria-hidden="true"></i> Matrix</a>
          · <a href="https://github.com/iaguozhi" rel="noopener"><i class="fab fa-github" aria-hidden="true"></i> GitHub</a>
          · <a href="https://twitter.com/iaguozhi" rel="noopener"><i class="fab fa-twitter" aria-hidden="true"></i> Twitter</a>
          <br>
          <span class="location"><i class="fas fa-map-marker"></i> ShangHai, China</span>
        </div>
        <div class="col-md">
          <p class="disclaimer">
            &copy; 2022 &mdash; 2022<br>
            All text is available under the <a href="https://creativecommons.org/licenses/by-sa/4.0/">CC-BY-SA 4.0</a> license<br>
            All code is available under the <a href="https://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a> license
          </p>
      </div>

    </footer>
  </div>

  <!-- webfonts & icons-->
  <link href="/static/fontawesome/css/fontawesome-all.min.css" rel="stylesheet">

  <!-- Google Analytics (that's right, I'm tracking you) -->
  <script async="" src="https://www.google-analytics.com/analytics.js"></script>
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-47725506-1', 'blog.thea.codes');
    ga('send', 'pageview');

  </script>

</body>
</html>